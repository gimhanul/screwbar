## 6-3. ì›í˜• í



íì˜ ê³µê°„ì  í™œìš©ì„ ë†’ì´ê¸° ìœ„í•´ ì‹œì‘ê³¼ ëì„ ì—°ê²°í•œ êµ¬ì¡°

frontì™€ rearê°€ ë°°ì—´ì˜ ëì—ì„œ ì¦ê°€í•˜ë©´ `ë°°ì—´ì˜ ì²˜ìŒ`ì„ ê°€ë¥´í‚¤ë„ë¡ í•¨.

â†’ ë‚˜ë¨¸ì§€ ì—°ì‚°ì í™œìš©

![Untitled 1](https://user-images.githubusercontent.com/80656733/152335546-12ea9ca9-8413-4ff9-befd-cadb81dc6c24.png)

ì´ë•Œ, ì›í˜•íì—ëŠ” full ìƒíƒœì™€ empty ìƒíƒœì¼ ë•Œ front ê°’ê³¼ rear ê°’ì´ ê°™ë‹¤ëŠ” ë¬¸ì œê°€ ìˆìŒ. â†’ êµ¬ë¶„ ë¶ˆê°€ëŠ¥. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ frontì™€ rearì‚¬ì´ì— ê³µë°±ì„ í•˜ë‚˜ ë‘ .


> ğŸ‘‰ğŸ» full â†’ rear + 1 == front, empty â†’ front == rear

<br>

```c
// ì›í˜• í
#include <stdio.h>
#include <stdlib.h>

typedef int ELEMENT ;

typedef struct queue{
	ELEMENT * buf;
	int front;
	int rear;
	int size;
}QUEUE;

QUEUE * createQueue( int n ){
	QUEUE *temp = (QUEUE *) malloc( sizeof(QUEUE) );
	temp -> size = n+1;   // í•œ ì¹¸ì„ ë¹„ì›Œ ë†“ê¸° ìœ„í•¨
	temp -> rear = 0;
	temp -> front = 0;
	temp -> buf = (ELEMENT *)malloc(sizeof(ELEMENT)*temp->size);
	return temp;
}
int isFull( QUEUE *q ){
	return (q->rear + 1 ) % q->size == q->front;
}
void enQueue( QUEUE *q, ELEMENT data ){
	if( isFull( q ) ) printf("Queue is full\n");
	else {
		q->rear = (q->rear + 1 ) % q->size;
		q->buf[ q->rear ] = data;
	}
}
int isEmpty( QUEUE *q ){
		return q->rear == q->front;
}
ELEMENT deQueue( QUEUE *q ){
	if( isEmpty( q ) ){
		printf("Queue is empty");
		return 0;
	}
	q->front = (q->front + 1 ) % q->size;
	return q->buf[ q->front ];
}
void destroyQueue( QUEUE * q ){
	free( q->buf );
	free( q );
}
void printAll( QUEUE *q ){
	int i;
	if( isEmpty(q)) return;
	
	int end = (q->front < q->rear) ? q->rear : q->rear + q->size;
	
	for(i = q->front+1; i <= end; i++) {
		printf("%d ", q->buf[i%(q->size)]);
	}
	
	printf("\n");
}
```