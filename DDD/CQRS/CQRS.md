## 11.2. CQRS `Command Query Responsibility Segregation`

시스템이 제공하는 기능은 크게 두 가지로 나눌 수 있음.

- 상태 변경
- 상태 정보 조회


도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경함. 
즉, 상태를 변경하는 범위와 상태를 조회하는 범위가 일치하지 않기 때문에 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해짐.
단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위한 방법이 바로 CQRS 임.

<br>

### CQRS

**명령 `Command`** 를 위한 모델과 상태를 제공하는 **조회 `Query`** 를 위한 모델을 분리하는 패턴임.

![](https://images.velog.io/images/ayoung0073/post/beac9fc8-180c-407f-8735-650207592640/image.png)

CQRS 는 복잡한 도메인에 복잡함. 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 남.
이런 도메인에 CQRS 를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 기능 때문에 도메인 모델이 복잡해지는 것을 막을 수 있음.

<br>

### 구현 기술

CQRS 를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있음.

![](https://velog.velcdn.com/images%2Fayoung0073%2Fpost%2Faf57651a-c76d-4480-b833-4fa1f8b9d52a%2Fimage.png)

조회 모델에는 응용 서비스가 존재하지 않을 수 있음. 단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하지 않기 때문에 컨트롤러에서 바로 DAO 를 실행해도 무방함.

<br>

### 명령 모델과 조회 모델의 설계

상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현함.
이는 **도메인 로직을 수행하는 데 초점**을 맞춰 설계함.

반면에 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고 있는 데이터 타입을 이용함.
이는 **화면에 보여줄 데이터를 조회하는 데 초점**을 맞춰 설계함.

![](https://velog.velcdn.com/images%2Fayoung0073%2Fpost%2Fcf69e47b-b7e8-454c-9b89-1953df86694a%2Fimage.png)

<br>

### 데이터 저장소

명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있음.

명령 모델은 트랙잭션을 지원하는 RDBMS 를 사용하고, 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL 을 사용할 수 있음.

![](https://blog.kakaocdn.net/dn/PrunM/btrI9mev2ge/mbTB8KxOv4bdKmpbKn0G71/img.png)

두 데이터 저장소 간 데이터 동기화는 **이벤트**를 활용해 처리함.
명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영함.

명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있음.

<br>

### 웹과 CQRS

일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많음.

조회 기능 요청 비율이 월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 다양한 기법을 사용함.

- 쿼리를 최적화해서 쿼리 실행 속도 자체를 높임.
- 메모리에 조회 데이터를 캐싱 해서 응답 속도를 높임.

이렇게 다양한 기법을 사용하는 것은 결과적으로 CQRS 를 적용하는 것과 같은 효과를 만듦.

- 메모리에 캐싱하는 데이터는 DB 에 저장된 데이터를 그대로 저장하기보다는 화면에 맞는 모양으로 변환한 데이터를 캐싱 할 때 성능에 더 유리함.
- 조회 속도를 높이기 위해 쿼리를 최적화한다는 것은 조회 화면에 보여줄 데이터를 빠르게 읽어올 수 있도록 쿼리를 작성하는 것임.

<br>

### CQRS 장단점

**장점**

- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있음.
- 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아짐.
- 조회 성능을 향상시키는 데 유리함.
  - 조회 단위로 캐시 기술을 적용할 수 있음.
  - 조회에 특화된 쿼리를 마음대로 사용할 수 있음.
  - 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수 있음.
  - 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않음.

**단점**

- 구현해야 할 코드가 더 많음. (→ 비용을 따져서 적합한 방식을 채택해야 함.)
- 더 많은 구현 기술이 필요함.
