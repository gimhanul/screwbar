## 3.4. ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼, 애그리거트도 다른 애그리거트를 참조함.

애그리거트의 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같음.

### 문제점 

ORM 기술 덕에 애그리거트 루트에 대한 참고를 쉽게 구현할 수 있고, 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터를 쉽게 조회할 수 있음.

하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있음.

- 편한 탐색 오용
  - 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있어, 다른 애그리거트의 상태를 쉽게 변경할 수 있게 됨.
  - 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만듦.
- 성능에 대한 고민
  - 로딩 시점 같은 다양한 경우의 수를 고려하여 연관 매핑과 JPQL/Criteria 쿼리의 전략을 결정해야 함.
- 확장 어려움
  - 사용자가 늘고 트래픽이 증가하면 부하를 분산하기 위해 도메인별로 시스템을 분리하기 시작함.
  - 즉, 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA 와 같은 단일 기술을 사용할 수 없음.

<br>

### ID 를 이용한 간접 참조


ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결됨.

이는 다음의 장점이 있음.

- 애그리거트 경계를 명확히 함.
- 애그리거트 간 물리적 연결을 제거하므로 모델의 복잡도를 낮춤.
- 애그리거트 간의 의존을 제거하므로 응집도를 높임.
- 구현 복잡도가 낮아짐.
- 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있음.
- 외부 애그리거트를 직접 참조하지 않기 떄문에 애초에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없음.
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해짐.

<br>

### ID 를 이용한 참조와 조회 성능

다른 애그리거트를 ID 로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있다.

한 DBMS 에 데이터가 있다면 조인을 이용해서 한 번에 모든 데이터를 가져올 수 있음에도 불구하고, 주문마다 상품 정보를 읽어오는 N+1 조회 문제가 생김.

N+1 조회 문제는 더 많은 쿼리를 실행하기 때문에 전체 조회 속도가 느려지는 원인이 됨.

이를 해결하기 위해서, 조회 전용 쿼리를 사용할 수 있음. 데이터 조회를 위한 별도 DAO 를 만들고, 조인을 이용해 한 번의 쿼리로 필요한 데이터를 로딩하면 됨.

> 또는 캐시를 적용하거나 조회 전용 저장소를 따로 구성하는 방법도 있음.
> 이 방법은 코드가 복잡해지는 단점이 있지만, 시스템의 처리량을 높일 수 있다는 장점이 있음.
